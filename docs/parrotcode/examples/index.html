[% page.title = "Parrot examples" %]
[% page.style = "default.html" %]
[% page.sidebar = INCLUDE "tpl/navigation.html" %]


<p>
Eventually this section of the site will become a full introduction to
Parrot assembly code. Please be patient while it is built.
</p>

<h2>Introduction</h2>

<p>
Parrot is a virtual machine used to efficiently execute bytecode for
interpreted languages - specifically, Perl 6, although we would like
to keep the door open for other languages in the future. As such,
Parrot will be the core of the Perl interpreter; it will be the target
platform to which Perl 6 code is compiled.
</p>

<p>
Parrot currently consists of an assembler and a virtual
machine. The best introduction to the Parrot virtual machine
is an article by Simon Cozens, 
<a href="http://www.perl.com/pub/a/2001/09/18/parrot.html">Parrot: Some Assembly Required</a>, and it is 
strongly recommended that you read that before continuing.
Note that the pace of Parrot development is currently quite fast and
some of the details in the article are out of date. This guide
will attempt to keep up to date to the latest CVS Parrot sources.
</p>

<p>
Parrot is intended to be the virtual machine for Perl 6, but it is not tied to Perl 6.
In fact, we hope Parrot can be a valid target architecture and common language
runtime for many languages. This can only be achieved through detailed Parrot examples
and explanations - the purpose of this site.
</p>

<p>
Download and install the latest version of Parrot if you have not already done so. 
</p>

<h2>Recent changes</h2>

<p>
The calling conventions have been completely changed from callee-save
to caller-save. The examples have been updated and are now much more
comprehensive.
</p>

<p>
Updated the examples to work with the new assembler.
</p>

<h2>Parrot assembler</h2>

<p>
Parrot assembler is a low-level language which compiles directly into
the Parrot virtual machine. Unlike most other virtual machines (but
like most real computers), Parrot is register-based. It has 32
registers of four different types: integers, numbers, strings, and
PMCs. These are named I0...I31, N0...N31, S0...S31, P0...P31. Most
Parrot operators have the same format: the name of the operator, the
destination register, and the operands.
</p>

<p>
The Parrot assembly language documentation (PDD6)
(<tt>docs/parrot_assembly.pod</tt> in the source distribution) is the
main source of information about the assembly language, so you should
read that for full information about the language.
</p>

<h2>Hello world!</h2>

<p>
The first example clearly has to be an example that prints out "Hello
world!". What could be simpler than the following code:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        # Trivial example
        print &quot;Hello world!\n&quot;
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
If you save this small file as "hello.pasm", you can assemble the code
to bytecode with <tt>./assemble.pl hello.pasm -o hello.pbc</tt> and
actually run the code with <tt>./parrot hello.pbc</tt> which will
indeed print out "Hello world!".
</p>

<p>
Note that the first line in the file is a comment, which starts with a
'#' character - everything until the end of the line is counted as a
comment. Note the last line contains the operator <tt>end</tt> which
stops execution of the program.
</p>

<h2>Assignment</h2>

<p>
Assignment between registers is done with the <tt>set</tt>
operator. The following code sets the first integer register to 1, the
first number register to 4.2 and the first string register to
"Resting". It will then print them all out, resulting in "1, 4.200000, Resting":
<p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 1
        set     N1, 4.2
	set     S1, &quot;Resting&quot;
	print   I1
	print   &quot;, &quot;
	print   N1
	print   &quot;, &quot;
	print	S1
	print   &quot;\n&quot;
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
Note how it seems that the print operator is polymorphic - it can
print integers, numbers, strings, and string constants. Actually,
these are all separate operators (for details look in
<tt>core.ops</tt> in the source distribution) - the assembler
decides which to use, keeping our code simple.
</p>

<p>
The <tt>set</tt> operator can also copy between registers of
the same type.
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 10
        set     I2, 20
        set     I3, 30
        set     I1, I3
        print   I1
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
Remember that the first operand is the destination register, so that
last command sets the value of register I1 to the value of register
I3. That is, I1 will hold the value 30.
</p>

<p>
To copy between registers of different types, the <tt>set</tt>
operator is used:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 10
        set     N1, I1
        set     N2, 4.2
        set     I2, N2
        print   N1
        print   &quot;, &quot;
        print   I2
        print   &quot;\n&quot;
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
The above code prints "10.000000, 4". Note that at the moment there
are no operators to convert from or to strings.
</p>

<h2>Arithmetic operators</h2>

<p>
A number of Parrot operators are concerned with arithmetic. The
<tt>inc</tt> and <tt>dec</tt> operators increase/decrease an integer
or number register by a constant. If no constant is given, 1 is
assumed. The following code prints out "13, 39.000000":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 10
	inc	I1       # I1 is now 11
        inc     I1, 2    # I1 is now 13
        set     N1, 42.0
        dec     N1       # N1 is now 41.0
        dec     N1, 2.0  # N1 is now 39.0
	print   I1
	print   &quot;, &quot;
	print   N1
	print   &quot;\n&quot;
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
More common arithmetic operators are: <tt>add</tt>, <tt>sub</tt>,
<tt>mul</tt> and <tt>div</tt>, which add, subtract, multiply and
divide the contents of registers:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 2
        set     I2, 4
        add     I3, I1, I2  # I3 is now 6 (2+4)
        sub     I3, I1, I2  # I3 is now -2 (2-4)
        mul     I3, I1, I2  # I3 is now 8 (2*4)
        div     I3, I2, I1  # I3 is now 2 (4/2)
	add	I1, I1, 5   # I1 is now 7
        set     N1, 1
        set     N2, 3
        div     N3, N1, N2  # N3 is now 0.333333
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
Note that <tt>add I1, I1, 5</tt> is also valid: constants
are allowed as well as registers for the last operand.
</p>

<p>
There are also other arithmetic operators, such as <tt>mod</tt>
(modulo) and a whole host of transcendental operators (<tt>sin</tt>,
<tt>cos</tt>, <tt>pow</tt>, <tt>exp</tt>, <tt>log10</tt>...).
</p>

<h2>String operators</h2>

<p>
Parrot includes a minimal set of string operators: <tt>length</tt>
(find the length of a string), <tt>chopn</tt> (remove characters from
the end of the string), <tt>concat</tt> (concatenate one string to the
end of another), <tt>substr</tt> (extract substrings), <tt>repeat</tt>
(repeat a string), <tt>index</tt> (search for a substring):
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     S1, &quot;Fourty&quot;
        set     S2, &quot;two&quot;
        length  I1, S2      # I1 is now 3
	concat  S1, S2      # S1 is now &quot;Fourtytwo&quot;
	concat  S3, S1, S2  # S3 is &quot;Fourtytwotwo&quot;
	substr  S2, S1, 0, 4 # S2 is &quot;Four&quot;
        chopn   S1, 3       # S1 is now &quot;Fourty&quot;
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
Note that the two-argument <tt>concat</tt> concatenates the second
string onto the end of the first: unlike most other operators is does
not create a whole new concatenated string. There is a three-argument
version which can do this, however.
</p>

<h2>Branching and conditionals</h2>

<p>
Branching is terribly useful in a program. The <tt>branch</tt>
operator is similar to a "goto", and takes a label. Labels are
presented at the start of the line with a colon. The following code
prints "Beautiful plumage!":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     S1, &quot;Beautiful&quot;
        branch  CHOIR
EX:     print   S1
        branch  END
CHOIR:  set     S2, &quot; plumage!\n&quot;
        concat  S1, S2
        branch  EX
END:    end
</td></tr></table></td></tr></table></td></tr></table>


<p>
The following conditional operators are available: <tt>eq</tt>
(equal), <tt>ne</tt> (not equal), <tt>lt</tt> (less than), <tt>le</tt>
(less than or equal), <tt>gt</tt> (greater than), <tt>ge</tt> (greater
than or equal). They take two integer or numeric registers and a label
to jump to if the condition is true. The following code prints the
numbers from 1 to 10, by looping over until I1 is greater than 10:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 1
REDO:   gt      I1, 10, END
        print   I1
        print   &quot;\n&quot;
        inc     I1
        branch  REDO
END:    end
</td></tr></table></td></tr></table></td></tr></table>


<p>
The conditional operators take a register and either a constant or
another register.
</p>

<p>
Note that a slightly shorter (and faster) simple loop like the code
above can be crafted. It is faster as it eliminates the
<tt>branch</tt> inside the loop, but does require another label if
you are unsure if the loop will be run at all:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 1
	branch  LOOP
REDO:   print   I1
        print   &quot;\n&quot;
        inc     I1
LOOP:   le      I1, 10, REDO
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
The <tt>if</tt> opcode tests if a register holds a true value. Any
value other than zero is true, so the following code prints "True!":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        set     I1, 1
        if      I1, TRUE
        print   &quot;False!\n&quot;
        branch  END
TRUE:   print   &quot;True!\n&quot;
END:    end
</td></tr></table></td></tr></table></td></tr></table>


<p>
Note that an early version of Parrot used conditional operators which
had an additional label to jump to if the condition was false. This is
no longer available: on false, the operators now fall through to the
next instruction.
</p>

<h2>Subroutines</h2>

<p>
Subroutines are a vital part of larger programs.
</p>

<p>
The simplest kind of subroutine is one that does not pass or return
arguments. The important operators here are <tt>bsr</tt> (Branch
SubRoutine, which jumps to a label) and <tt>ret</tt> (RETurn, which
returns from a subroutine). The following code jumps to a subroutine
named HW which prints out "Hello there!" and then returns:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	bsr     HELLO
	end

HELLO:  print &quot;Hello there!\n&quot;
        ret
</td></tr></table></td></tr></table></td></tr></table>


<p>
When coding Parrot assembler, it is very important to know about the
Parrot parameter passing conventions. These are documented in PDD03:
Parrot Calling Conventions, available in
<tt>docs/pdds/pdd03_calling_conventions.pod</tt>.  The most important
point is that the caller is responsible for preserving any environment
it is interested in keeping.  When calling a subroutine, I0 is true if
it is being called with prototyped parameters. I1 holds the number of
items pushed on the stack. If called with parameters, I5-I31, S5-S31,
P5-P31 and N5-N31 holds the integer, string, PMC and numeric
parameters. All overflow parameters and parameters called without
prototyped parameters are put on the stack in reverse order.
</p>

<p>
Return conventions are also important. On return from a subroutine, I0
holds the number of return values on the stack, I1-I4 the number of
return values in the integer, string, PMC and numeric registers.
I5-I31, S5-S31, P5-P31 and N5-N31 hold any integer, string, PMC and
numeric return values. The stack holds overflow values or values for
functions that don't have a return prototype.
</p>

<p>
It is important to bear the above conventions in mind, especially for
larger examples. In the small examples so far, we have been able to
optimise the code as we control the entire code base. From now on, we
are going to play nice and follow the rules.
</p>

<p>
Our first example will be a subroutine that doubles its first integer
argument. A trivial task you may think, but we're going to follow the
conventions by the book and set up the calling and returning
environments correctly. The example also does error checking to make
sure the subroutine has been called in the right way and the caller
checks that the subroutine returns the values that it is expecting.
It prints "84 was returned":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	set	I0, 1 # prototyped
	set	I1, 0 # no items on the stack
	set 	I5, 42
	bsr	DOUBLE
	ne	I0, 0, RETURNERROR # item on stack
	ne	I1, 1, RETURNERROR # not 1 integer return value
	ne	I2, 0, RETURNERROR # string return values
	ne	I3, 0, RETURNERROR # PMC return values
	ne	I4, 0, RETURNERROR # numeric return values
	print	I5
	print	&quot; was returned\n&quot;
	end

RETURNERROR:
	print	"Error with return values from DOUBLE!\n"
	end

DOUBLE: ne	I0, 1, CALLERROR # not prototyped
	ne	I1, 0, CALLERROR # items on stack

	mul	I5, I5, 2

	set	I0, 0 # no items on the stack
	set	I1, 1 # one integer return value
	set	I2, 0 # no string return values
	set	I3, 0 # no PMC return values
	set	I4, 0 # no numeric return values
	ret

CALLERROR:
	print	"Error calling DOUBLE!\n"
	end
</td></tr></table></td></tr></table></td></tr></table>

<p>
Note that in the example above we're assuming that the we know the
prototype and thus pass around an integer value in I5. The next
example passes the value on the stack. Note the use of the 
<tt>save</tt> and <tt>restore</tt> operators to push and pop things
from the stack.
</p>

<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	save	42
	set	I0, 0 # not prototyped
	set	I1, 1 # one item on the stack
	bsr	DOUBLE
	ne	I0, 1, RETURNERROR # no item on stack
	ne	I1, 0, RETURNERROR # integer return values
	ne	I2, 0, RETURNERROR # string return values
	ne	I3, 0, RETURNERROR # PMC return values
	ne	I4, 0, RETURNERROR # numeric return values
	restore I0
	print	I0
	print	" was returned\n"
	end

RETURNERROR:
	print	"Error with return values from DOUBLE!\n"
	end

DOUBLE: ne	I0, 0, CALLERROR # prototyped
	ne	I1, 1, CALLERROR # no item on stack

	restore	I0
	mul	I0, I0, 2
	save	I0

	set	I0, 1 # one item on the stack
	set	I1, 0 # no integer return values
	set	I2, 0 # no string return values
	set	I3, 0 # no PMC return values
	set	I4, 0 # no numeric return values
	ret

CALLERROR:
	print	"Error calling DOUBLE!\n"
	end
</td></tr></table></td></tr></table></td></tr></table>

<p>
The next example finds the greatest common divisor of two integers
(passed in I5 and I6) and returns the value, as per the convention, in
I5. This should print "32 was returned":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	set	I0, 1 # prototyped
	set	I1, 0 # no items on the stack
	set 	I5, 96
	set     I6, 64
	bsr	EUCLID
	ne	I0, 0, RETURNERROR # item on stack
	ne	I1, 1, RETURNERROR # not 1 integer return value
	ne	I2, 0, RETURNERROR # string return values
	ne	I3, 0, RETURNERROR # PMC return values
	ne	I4, 0, RETURNERROR # numeric return values
	print	I5
	print	" was returned\n"
	end

RETURNERROR:
	print	"Error with return values from EUCLID!\n"
	end

EUCLID: ne	I0, 1, CALLERROR # not prototyped
	ne	I1, 0, CALLERROR # items on stack

LOOP:   mod    I7, I5, I6
	eq     I7, 0, DONE
	set    I5, I6
        set    I6, I7
	branch	LOOP
DONE:   set     I5, I6

	set	I0, 0 # no items on the stack
	set	I1, 1 # one integer return value
	set	I2, 0 # no string return values
	set	I3, 0 # no PMC return values
	set	I4, 0 # no numeric return values
	ret

CALLERROR:
	print	"Error calling EUCLID!\n"
	end
</td></tr></table></td></tr></table></td></tr></table>


<p>

When passing a variable number of arguments to a subroutine, they are
passed on the generic Parrot stack in reverse order with the
<tt>save</tt> operator, and the number of arguments is passed in
I1. They can then be read into a register with the <tt>restore</tt>
operator. The following example code shows a subroutine that can
return the sum of a variable number of integers. This will print out
"60 was the sum":

</p>

<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	save	30
	save	20
	save	10
	set	I0, 0 # not prototyped
	set	I1, 3 # three items on the stack
	bsr	SUM
	ne	I0, 1, RETURNERROR # not one item on stack
	ne	I1, 0, RETURNERROR # integer return values
	ne	I2, 0, RETURNERROR # string return values
	ne	I3, 0, RETURNERROR # PMC return values
	ne	I4, 0, RETURNERROR # numeric return values
	restore I0
	print	I0
	print	" was the sum\n"
	end

RETURNERROR:
	print	"Error with return values from SUM!\n"
	end

SUM:	ne	I0, 0, CALLERROR # prototyped
        # we don't care how many items there are on the stack

	set     I2, 0 # the sum
REDO:   restore I3
	inc     I2, I3
	dec     I1
	if      I1, REDO

	save	I2

	set	I0, 1 # one item on the stack
	set	I1, 0 # no integer return values
	set	I2, 0 # no string return values
	set	I3, 0 # no PMC return values
	set	I4, 0 # no numeric return values
	ret

CALLERROR:
	print	"Error calling SUM!\n"
	end
</td></tr></table></td></tr></table></td></tr></table>


<p>
When returning back a variable number of values from a subroutine,
they are passed on the generic Parrot stack in reverse order much like
the above example. The example below takes in two arguments via I0 and
I1 and returns the list of integers that span between them. The
following code will print out all the numbers from 42 to 56:
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	set	I0, 1 # prototyped
	set	I1, 0 # no items on the stack
	set 	I5, 42
	set     I6, 56
	bsr	SPAN
	ne	I0, 0, RETURNERROR # item on stack
        # we don't know the number of integers values returned
	ne	I2, 0, RETURNERROR # string return values
	ne	I3, 0, RETURNERROR # PMC return values
	ne	I4, 0, RETURNERROR # numeric return values

MORE:   restore I2
	print   I2
	print   "\n"
	dec     I1
	if      I1, MORE
	end

RETURNERROR:
	print	"Error with return values from SPAN!\n"
	end

SPAN:	ne	I0, 1, CALLERROR # not prototyped
	ne	I1, 0, CALLERROR # items on stack

	set     I7, 0 # count of integers
REDO:   save    I6
	dec     I6
	inc     I7
	le      I5, I6, REDO

	set	I0, 0  # no items on the stack
	set	I1, I7 # one integer return value
	set	I2, 0  # no string return values
	set	I3, 0  # no PMC return values
	set	I4, 0  # no numeric return values
	ret

CALLERROR:
	print	"Error calling SPAN!\n"
	end
</td></tr></table></td></tr></table></td></tr></table>


<p>
If the caller requires that some registers keep their value over a
call to a subroutine, then it must save their value before the call
and restore them after it. The following code saves I5 before calling
BANNER so that even though BANNER overwrites I5 we restore it after
the call and end up printing "I5 is 4":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	set	I5, 4
	save	I5
	set	I0, 1 # prototyped
	set	I1, 0 # no items on the stack
	bsr	BANNER
	ne	I0, 0, RETURNERROR # item on stack
	ne	I0, 0, RETURNERROR # integer return values
	ne	I2, 0, RETURNERROR # string return values
	ne	I3, 0, RETURNERROR # PMC return values
	ne	I4, 0, RETURNERROR # numeric return values
	restore	I5
	print	"I5 is "
	print   I5
	print	"\n"
	end

RETURNERROR:
	print	"Error with return values from BANNER!\n"
	end

BANNER:	ne	I0, 1, CALLERROR # not prototyped
	ne	I1, 0, CALLERROR # items on stack

	set	I5, 10 # stomp over I5 for no reason
	print	"Hello there. Welcome to the program.\n"

	set	I0, 0 # no items on the stack
	set	I1, 0 # no integer return values
	set	I2, 0 # no string return values
	set	I3, 0 # no PMC return values
	set	I4, 0 # no numeric return values
	ret

CALLERROR:
	print	"Error calling BANNER!\n"
	end
</td></tr></table></td></tr></table></td></tr></table>


<h2>PMCs</h2>

<p>
PMCs are a completely abstracted data type; they may be string,
integer, code or anything else. They are roughly equivalent to the
SV, AV and HV (and more complex types) defined in Perl 5, and
almost exactly equivalent to PythonObject types in Python.
</p>

<p>
The various types of PMCs shipped with Parrot are defined in the file
<tt>include/parrot/pmc.h</tt> - but this currently is Array,
PerlUndef, PerlInt, PerlNum, and PerlString, PerlArray, PerlHash,
ParrotPointer and IntQueue.
</p>

<p>
To use a PMC, you must first create it using the <tt>new</tt>
operator. You can then assign it a value and treat it much like the
lower-level types. The following code creates two PerlInt PMCs and
adds them together, printing out "444":
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
        new P0, .PerlInt
        set P0, 123
        new P1, .PerlInt
        set P1, 321
        add P1, P1, P0
	print P1
        print &quot;\n&quot;
        end
</td></tr></table></td></tr></table></td></tr></table>


<p>
It is important to note that Perl integers also behave as strings and
that PMCs can change their own type on the fly. The following code
concatenates a number and a string. So while P0 starts off as a
PerlInt at the beginning, it is changed to a PerlString when a string
is concatenated to it. In that way, the following prints out "42 is
the answer!".
</p>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
	new     P0, .PerlInt
        set     P0, 42
	new     P1, .PerlInt
	set     P1, " is the answer!"
	concat  P0, P0, P1
        print   P0
        print   "\n"
        end
</td></tr></table></td></tr></table></td></tr></table>


<h2>Future sections</h2>

<p>
More sections to be added here. A great deal of the Parrot development
process time is being spent on getting the internals right, so it may
seem that Parrot development is slow. Future versions of Parrot will
have scalar and list PMCs, then hash PMCs. Great things will happen.
</p>

<p>
The rest of this examples page consists of short, easy-to-understand
Parrot examples.
</p>

<h2>Fibonacci</h2>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
# Simple code to print some Fibonacci numbers
# Leon Brocard &lt;acme@astray.com&gt;

	print 	&quot;The first 20 Fibonacci numbers are:\n&quot;
	set 	I1, 0
        set 	I2, 20
        set 	I3, 0
        set 	I4, 1
REDO: 	set	I5, I4
	add	I4, I3, I4
	set	I3, I5
	print 	I3
	print 	&quot;\n&quot;
	inc	I1
	lt 	I1, I2, REDO
DONE:	end
</td></tr></table></td></tr></table></td></tr></table>


<h2>Factorial</h2>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
# Some simple code to print some factorials
# Leon Brocard &lt;acme@astray.com&gt;

	print 	&quot;The first 15 factorials are:\n&quot;
	set	I1, 0
        set	I2, 15
        set	I3, 1
REDO:	inc	I1
	mul	I3, I3, I1
	print	I3
	print	&quot;\n&quot;
   	lt	I1, I2, REDO
DONE:	end
</td></tr></table></td></tr></table></td></tr></table>


<h2>Primes</h2>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
# Some simple code to print out the primes up to 100
# Leon Brocard &lt;acme@astray.com&gt;

	# I1 holds the number we're currently checking for primality
	set     I1, 1
	# I2 holds the highest number we want to check for primality
	set     I2, 100
	print   &quot;The primes up to &quot;
	print   I2
	print   &quot; are:\n&quot;
	# I1 counts up to I2
REDO:   # I3 counts from 2 up to I4 (I1/2)
	set     I3, 2
	div     I4, I1, 2
LOOP:   # Check if I3 is a factor of I1
	mod     I5, I1, I3
	if      I5, OK
	# We've found a factor, so it can't be a prime and
	# we can skip right out of this loop and to the next
	# number
	branch  NEXT
OK:     inc     I3
	le      I3, I4, LOOP
	# We haven't found a factor so it must be a prime
	print   I1
	print   &quot;\n&quot;
NEXT:   # Move on to the next number
	inc     I1
	le      I1, I2, REDO
	end
</td></tr></table></td></tr></table></td></tr></table>


<h2>Leibniz summation for PI</h2>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
# Simple code to calculate the Leibniz summation for
# PI, which is:
#
# PI/4 = 1/1 - 1/3 + 1/5 - 1/7 + 1/9 ....
#
# (The summation isn't a very good one)
#
# N1 is the first denominator
# N2 is the last denominator to evaluate for
# N3 is the location of the current fraction
# N4 is the summation
# I1 is a flag determining whether to add (0)
# or subtract (1) N4 to/or from N3
#
# By Greg McCarroll

	set     N1, 1
	set     N2, 1000000
	set     N3, 0
	set     N4, 0
	set     I1, 0
REDO:   div     N4, 1.0, N1
	if      I1, SUB
	add     N3, N4, N3
	set     I1, 1
	branch  END
SUB:    sub     N3, N3, N4
	set     I1, 0
END:    inc     N1, 2
	le      N1, N2, REDO
DONE:   mul     N3, N3, 4.0
	print   &quot;PI is (very) approximately: &quot;
	print   N3
	print   &quot;\n&quot;
	end
</td></tr></table></td></tr></table></td></tr></table>


<h2>Mandlebrot generator</h2>


<table CELLPADDING="1" CELLSPACING="0" BORDER="0"
bgcolor="#0000ff"><tr><td><table WIDTH="600" BORDER="0"
CELLPADDING="0" CELLSPACING="0" bgcolor="#ccccff"><tr><td><table CELLPADDING="12" CELLSPACING="0"><tr><td><pre>
# Print the Mandlebrot set
#
# Translated from C code by Glenn Rhoads into Parrot assembler
# by Leon Brocard &lt;acme@astray.com&gt;
#
# The C code is:
#
# main(){
#
#  int x, y, k;
#  char *b = &quot; .:,;!/&gt;)|&amp;IH%*#&quot;;
#  float r, i, z, Z, t, c, C;
#  for (y=30; puts(&quot;&quot;), C = y*0.1 - 1.5, y--;){
#     for (x=0; c = x*0.04 - 2, z=0, Z=0, x++ &lt; 75;){
#        for (r=c, i=C, k=0; t = z*z - Z*Z + r, Z = 2*z*Z + i, z=t, k&lt;112; k++)
#           if (z*z + Z*Z &gt; 10) break;
#        printf (&quot;%c&quot;, b[k%16]);
#        }
#     }
# }
#
# We store the following variables in these registers:
#  x,  y, k
# I1, I2, I3
#
#  r,  i,  z,  Z,  t,  c, C
# N1, N2, N3, N4, N5, N6, N7

	set S1, &quot; .:,;!/&gt;)|&amp;IH%*#&quot;
	set I2, 30

YREDO:  #  C = y*0.1 - 1.5
	set N8, I2
	set N9, 0.1
        mul N7, N8, N9
	set N8, 1.5
	sub N7, N7, N8

	set I1, 0

XREDO:  # c = x*0.04 - 2
        set N8, I1
	set N9, 0.04
	mul N6, N8, N9
	set N8, 2.0
	sub N6, N6, N8
	set N3, 0
	set N4, 0

        set N1, N6
        set N2, N7

        set I3, 0

KREDO:  # t = z*z - Z*Z + r
        mul N8, N3, N3
        mul N9, N4, N4
        sub N5, N8, N9
        add N5, N5, N1

        # Z = 2*z*Z + i
        add N4, N4, N4
        mul N4, N4, N3
        add N4, N4, N2

        # z = t
        set N3, N5

        # if (z*z + Z*Z &gt; 10) break;
        mul N8, N3, N3
        mul N9, N4, N4
        add N8, N8, N9
        gt N8, 10.0, PRINT

	inc I3
	lt I3, 112, KREDO

PRINT:  mod I4, I3, 16
        substr S2, S1, I4, 1
	print S2

	inc I1
	lt I1, 75, XREDO

	print &quot;\n&quot;
	dec I2
	gt I2, 0, YREDO

END:    end
</td></tr></table></td></tr></table></td></tr></table>



